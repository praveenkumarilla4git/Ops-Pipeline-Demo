ðŸ“˜ Full DevOps Pipeline Project: From Zero to Live
Objective: Build a Python web app, version control it with Git, provision AWS infrastructure with Terraform, configure the server with Ansible, and deploy using Docker. Finally, perform a live update without downtime.
#############################################################################################
0. Prerequisites
Before starting, ensure you have:
AWS Account (Free Tier).
VS Code installed.
Git installed and configured (git config --global user.name ...).
Terraform installed.
WSL (Ubuntu) installed on Windows (for Ansible).
AWS CLI configured with your credentials (aws configure or env vars).
S3 Bucket created for Terraform State (e.g., tf-state-praveen-2025 in eu-north-1).
EC2 Key Pair (tf-key2.pem) saved locally.

Create a parent folder named DevOps-Project. Inside, create three sub-folders. Your final structure will look like this:
ðŸ“‚ DevOps-Project/
â”‚
â”œâ”€â”€ ðŸ“‚ Ops-Pipeline-Demo/       (Source Code & Git)
â”‚     â”œâ”€â”€ ApplicationCode/
â”‚     â”‚     â”œâ”€â”€ app.py
â”‚     â”‚     â””â”€â”€ index.html      (Generated by Python)
â”‚     â”œâ”€â”€ .gitignore
â”‚     â””â”€â”€ ReadMe.md
â”‚
â”œâ”€â”€ ðŸ“‚ Ops-Infra/               (Terraform Infrastructure)
â”‚     â”œâ”€â”€ main.tf
â”‚     â”œâ”€â”€ variables.tf
â”‚     â”œâ”€â”€ outputs.tf
â”‚     â””â”€â”€ .terraform/           (Created by init)
â”‚
â””â”€â”€ ðŸ“‚ Ops-Ansible/             (Ansible Configuration)
      â”œâ”€â”€ deploy.yml
      â”œâ”€â”€ hosts.ini
      â””â”€â”€ tf-key2.pem           (Copy your key here)

Phase 1: The Application (Python & Git)
Goal: Create the "Product" and push it to GitHub safely.
1. Create the App Code
Location: Ops-Pipeline-Demo/ApplicationCode/

File: app.py
######### Contents of app.py ################
import datetime
# 1. Get current time
now = datetime.datetime.now()
# 2. Define the website content
html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Ops-Pipeline-Demo</title>
    <style>
        body {{ background-color: #2D2D2D; color: #ffffff; font-family: Arial, sans-serif; text-align: center; padding-top: 50px; }}
        .box {{ border: 2px solid #4CAF50; padding: 20px; display: inline-block; border-radius: 10px; }}
        h1 {{ color: #4CAF50; }}
    </style>
</head>
<body>
    <div class="box">
        <h1>Deployment Successful!</h1>
        <h2>Project: Ops-Pipeline-Demo</h2>
        <p>Generated by: <b>Python</b></p>
        <p>Served by: <b>Nginx in Docker</b></p>
        <hr>
        <p>Timestamp: {now}</p>
    </div>
</body>
</html>
"""

# 3. Create the index.html file
with open("index.html", "w") as file:
    file.write(html_content)

print(f"SUCCESS: index.html created at {now}")

2. Create the Git Ignore Shield (CRITICAL)
Location: Ops-Pipeline-Demo/ (Root folder)
File: .gitignore
############ Contents of .gitignore file ##########
.terraform/
*.tfstate
*.tfstate.backup
**/.terraform/*
**/terraform.tfstate
Ops-Infra/.terraform/
__pycache__/
*.pem

3. Push to GitHub Run in VS Code Terminal (inside Ops-Pipeline-Demo):
git init
git add .
git commit -m "Initial commit - v1 App"
git branch -M main
git remote add origin https://github.com/[YOUR_USERNAME]/Ops-Pipeline-Demo.git
git push -u origin main

Phase 2: The Infrastructure (Terraform)
Goal: Provision an Ubuntu Server on AWS.
1. Define Variables
Location: Ops-Infra/
File: variables.tf
########### Contents of Variables.tf ################
variable "aws_region" {
  default = "us-east-1" # N. Virginia
}
variable "instance_type" {
  default = "t3.micro"
}
variable "key_name" {
  default = "tf-key2" 
}
variable "ami_id" {
  default = "ami-0e2c8caa4b6378d8c" # Ubuntu 24.04 LTS (us-east-1)
}



2. Define Infrastructure
Location: Ops-Infra/
File: main.tf
########### Contents of main.tf ###################

Terraform

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  backend "s3" {
    bucket = "tf-state-praveen-2025"
    key    = "ops-infra/terraform.tfstate"
    region = "eu-north-1"  # Your Bucket Location
  }
}

provider "aws" {
  region = var.aws_region
}

# Security Group
resource "aws_security_group" "ops_sg" {
  name        = "ops_pipeline_sg"
  description = "Allow SSH and HTTP"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# EC2 Instance
resource "aws_instance" "app_server" {
  ami           = var.ami_id
  instance_type = var.instance_type
  key_name      = var.key_name
  vpc_security_group_ids = [aws_security_group.ops_sg.id]

  tags = {
    Name = "Ops-Demo-Ubuntu"
  }
}

3. Define Outputs
Location: Ops-Infra/
File: outputs.tf

############ Contents of outputs.tf ############
output "public_ip" {
  value = aws_instance.app_server.public_ip
}


4. Launch Run in VS Code Terminal (inside Ops-Infra):

terraform init
terraform apply
# Type 'yes' to confirm


Phase 3: The Configuration (Ansible)
Goal: Configure the server and deploy the Docker container. Requirement: Run these commands in WSL (Ubuntu Terminal).

Setup Workspace

mkdir -p ~/DevOps/Ops-Ansible
cd ~/DevOps/Ops-Ansible
# Copy your key here
cp /mnt/c/Users/[YOU]/Downloads/tf-key2.pem .
chmod 400 tf-key2.pem

2. Inventory File
File: hosts.ini
[webservers]
# REPLACE WITH YOUR TERRAFORM OUTPUT IP
3.85.xxx.xxx ansible_user=ubuntu ansible_ssh_private_key_file=./tf-key2.pem ansible_ssh_common_args='-o StrictHostKeyChecking=no'

3. The Playbook
File: deploy.yml

---
- name: Deploy Ops-Pipeline-Demo
  hosts: webservers
  become: yes

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Install Docker and Git
      apt:
        name:
          - docker.io
          - git
          - python3
        state: present

    - name: Clone the Application Code from GitHub
      git:
        repo: 'https://github.com/[YOUR_USERNAME]/Ops-Pipeline-Demo.git'
        dest: /home/ubuntu/app
        version: main
        force: yes

    # Crucial Fix: Pointing to the correct sub-folder
    - name: Run Python script to generate index.html
      command: python3 app.py
      args:
        chdir: /home/ubuntu/app/ApplicationCode

    - name: Stop existing container (if any)
      shell: docker rm -f my-website || true

    - name: Run Nginx Container
      shell: |
        docker run -d --name my-website -p 80:80 \
        -v /home/ubuntu/app/ApplicationCode/index.html:/usr/share/nginx/html/index.html \
        nginx

4. Deploy Run in WSL Terminal:
ansible-playbook -i hosts.ini deploy.yml

5. Verify Open the IP address in your browser. You should see "Deployment Successful".

Phase 4: The Live Update (v2.0)
Goal: Update the live website without destroying the server.

1. Modify Code (VS Code)

Open Ops-Pipeline-Demo/ApplicationCode/app.py.

Change <h1>Deployment Successful!</h1> to <h1>Ops Pipeline v2.0 is LIVE!</h1>.

Save.

2. Push Changes

git add .
git commit -m "Updating to v2.0"
git push

3. Re-Deploy (Ansible) Run in WSL Terminal:
ansible-playbook -i hosts.ini deploy.yml

4. Check Browser Refresh the page. It should instantly say "Ops Pipeline v2.0 is LIVE!".

Phase 5: Cleanup
Goal: Stop billing.
Run in VS Code Terminal (Ops-Infra):
terraform destroy
# Type 'yes'